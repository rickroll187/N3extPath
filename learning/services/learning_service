"""
LEGENDARY LEARNING & DEVELOPMENT SERVICE ENGINE üìöüöÄ
More educational than a Swiss university with legendary knowledge!
CODE BROS CREATE THE BEST AND CRACK JOKES TO HAVE FUN!
"""

import logging
from typing import Dict, List, Optional, Any, Tuple, Set
from datetime import datetime, timedelta
from sqlalchemy.orm import Session, joinedload
from sqlalchemy import and_, or_, func, desc, asc, text
from dataclasses import dataclass
import statistics
from enum import Enum
import json
import re
from collections import defaultdict, Counter

from ..models.learning_models import (
    Course, CourseEnrollment, CourseSkill, CourseAssessment, AssessmentSubmission,
    LearningPath, LearningPathCourse, LearningPathEnrollment,
    Skill, SkillCategory, EmployeeSkill,
    CourseStatus, EnrollmentStatus, SkillLevel, LearningPathType, AssessmentType
)
from ...core.auth.authorization import AuthContext, Permission
from ...core.database.base_models import Employee, User, Department, AuditLog

logger = logging.getLogger(__name__)

class LearningProgress(Enum):
    """Learning progress indicators - more precise than Swiss measurements!"""
    NOT_STARTED = "not_started"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    MASTERED = "mastered"

@dataclass
class LearningAnalytics:
    """
    Learning analytics that are more insightful than a Swiss education analyst!
    More comprehensive than a university research report with attitude! üéìüìä
    """
    total_courses_enrolled: int
    courses_completed: int
    completion_rate: float
    total_learning_hours: float
    skills_developed: int
    certifications_earned: int
    learning_streak_days: int
    average_course_rating: float

class LegendaryLearningService:
    """
    The most educational learning service in the galaxy!
    More inspiring than a Swiss university with unlimited knowledge! üìöüåü
    """
    
    def __init__(self, db: Session):
        self.db = db
        
        # LEARNING SERVICE JOKES FOR SUNDAY MORNING MOTIVATION
        self.learning_jokes = [
            "Why did the course go to therapy? It had completion issues! üìöüòÑ",
            "What's the difference between our learning and Swiss education? Both are perfectly structured! üè´",
            "Why don't our students ever get lost? Because they have legendary navigation! üß≠",
            "What do you call learning at 3 AM? Night shift education with style! üåô",
            "Why did the skill become a comedian? It had perfect development timing! üé≠"
        ]
        
        # Learning recommendation algorithms
        self.recommendation_weights = {
            "role_relevance": 0.3,        # How relevant to current role
            "career_progression": 0.25,   # Career advancement potential
            "skill_gap": 0.2,            # Current skill gaps
            "peer_popularity": 0.15,      # What peers are taking
            "completion_rate": 0.1        # Course success rate
        }
        
        # Skill level progression thresholds
        self.skill_progression = {
            SkillLevel.BEGINNER: {"min_hours": 0, "max_hours": 20, "courses": 1},
            SkillLevel.INTERMEDIATE: {"min_hours": 20, "max_hours": 100, "courses": 3},
            SkillLevel.ADVANCED: {"min_hours": 100, "max_hours": 300, "courses": 5},
            SkillLevel.EXPERT: {"min_hours": 300, "max_hours": 800, "courses": 8},
            SkillLevel.MASTER: {"min_hours": 800, "max_hours": float('inf'), "courses": 12}
        }
        
        # Assessment scoring thresholds
        self.scoring_thresholds = {
            "excellent": 90.0,
            "good": 80.0,
            "satisfactory": 70.0,
            "needs_improvement": 60.0,
            "unsatisfactory": 0.0
        }
        
        logger.info("üìö Legendary Learning Service initialized - Ready to educate the world!")
    
    def enroll_in_course(self, course_id: int, employee_id: Optional[int] = None,
                        enrollment_data: Optional[Dict[str, Any]] = None,
                        auth_context: AuthContext) -> Dict[str, Any]:
        """
        Enroll employee in course with more precision than Swiss registration!
        More exciting than joining a legendary university! üéì‚ú®
        """
        try:
            # Use current user if no employee_id specified
            target_employee_id = employee_id or auth_context.user_id
            
            logger.info(f"üìù Enrolling employee {target_employee_id} in course {course_id}")
            
            # Check permissions
            if target_employee_id != auth_context.user_id and not auth_context.has_permission(Permission.LEARNING_ADMIN):
                return {
                    "success": False,
                    "error": "You can only enroll yourself in courses"
                }
            
            # Get course
            course = self.db.query(Course).filter(Course.id == course_id).first()
            
            if not course:
                return {
                    "success": False,
                    "error": "Course not found"
                }
            
            # Check if course is available for enrollment
            if course.status != CourseStatus.PUBLISHED.value:
                return {
                    "success": False,
                    "error": "This course is not available for enrollment"
                }
            
            # Check enrollment deadline
            if course.enrollment_deadline and datetime.utcnow() > course.enrollment_deadline:
                return {
                    "success": False,
                    "error": "Enrollment deadline has passed"
                }
            
            # Check capacity
            if course.max_participants and course.enrollment_count >= course.max_participants:
                return {
                    "success": False,
                    "error": "This course is at full capacity"
                }
            
            # Check if already enrolled
            existing_enrollment = self.db.query(CourseEnrollment).filter(
                and_(
                    CourseEnrollment.course_id == course_id,
                    CourseEnrollment.employee_id == target_employee_id,
                    CourseEnrollment.status.in_([
                        EnrollmentStatus.ENROLLED.value,
                        EnrollmentStatus.IN_PROGRESS.value
                    ])
                )
            ).first()
            
            if existing_enrollment:
                return {
                    "success": False,
                    "error": "Already enrolled in this course"
                }
            
            # Check prerequisites
            prerequisite_check = self._check_course_prerequisites(course, target_employee_id)
            if not prerequisite_check["met"]:
                return {
                    "success": False,
                    "error": f"Prerequisites not met: {', '.join(prerequisite_check['missing'])}"
                }
            
            # Calculate estimated completion date
            estimated_completion = self._calculate_estimated_completion(course, target_employee_id)
            
            # Create enrollment
            enrollment = CourseEnrollment(
                course_id=course_id,
                employee_id=target_employee_id,
                enrolled_by_id=auth_context.user_id,
                enrollment_reason=enrollment_data.get("reason") if enrollment_data else None,
                status=EnrollmentStatus.ENROLLED.value,
                estimated_completion_date=estimated_completion,
                total_time_spent_hours=0.0,
                created_by=auth_context.user_id,
                updated_by=auth_context.user_id
            )
            
            self.db.add(enrollment)
            
            # Update course enrollment count
            course.enrollment_count += 1
            
            # Add course skills to employee skill tracking
            self._add_course_skills_to_employee(course, target_employee_id)
            
            # Generate learning recommendations
            recommendations = self._generate_related_courses(course, target_employee_id)
            
            # Log enrollment
            self._log_learning_action("COURSE_ENROLLMENT", enrollment.id, auth_context, {
                "course_id": course_id,
                "course_title": course.title,
                "employee_id": target_employee_id,
                "estimated_completion": estimated_completion.isoformat() if estimated_completion else None,
                "enrolled_by_self": target_employee_id == auth_context.user_id
            })
            
            self.db.commit()
            
            logger.info(f"‚úÖ Course enrollment successful: {course.title} for employee {target_employee_id}")
            
            return {
                "success": True,
                "enrollment_id": enrollment.id,
                "course_title": course.title,
                "course_duration_hours": course.estimated_duration_hours,
                "estimated_completion_date": estimated_completion.isoformat() if estimated_completion else None,
                "learning_objectives": course.learning_objectives or [],
                "related_courses": recommendations[:3],  # Top 3 recommendations
                "course_url": f"/courses/{course_id}",
                "legendary_joke": "Why did the enrollment become legendary? Because it was the first step to legendary knowledge! üìöüèÜ"
            }
            
        except Exception as e:
            self.db.rollback()
            logger.error(f"üí• Course enrollment error: {e}")
            return {
                "success": False,
                "error": f"System error: {str(e)}"
            }
    
    def update_course_progress(self, enrollment_id: int, progress_data: Dict[str, Any],
                             auth_context: AuthContext) -> Dict[str, Any]:
        """
        Update course progress with more precision than a Swiss tracking system!
        More accurate than a legendary progress monitor! üìàüéØ
        """
        try:
            logger.info(f"üìà Updating course progress for enrollment: {enrollment_id}")
            
            # Get enrollment
            enrollment = self.db.query(CourseEnrollment).filter(
                CourseEnrollment.id == enrollment_id
            ).first()
            
            if not enrollment:
                return {
                    "success": False,
                    "error": "Enrollment not found"
                }
            
            # Check permissions
            if enrollment.employee_id != auth_context.user_id and not auth_context.has_permission(Permission.LEARNING_ADMIN):
                return {
                    "success": False,
                    "error": "You can only update your own course progress"
                }
            
            # Validate progress data
            validation_result = self._validate_progress_data(progress_data)
            if not validation_result["is_valid"]:
                return {
                    "success": False,
                    "errors": validation_result["errors"]
                }
            
            # Update progress
            old_progress = enrollment.progress_percentage
            enrollment.progress_percentage = progress_data.get("progress_percentage", enrollment.progress_percentage)
            enrollment.last_accessed_at = datetime.utcnow()
            
            # Update time tracking
            if progress_data.get("time_spent_minutes"):
                enrollment.total_time_spent_hours += progress_data["time_spent_minutes"] / 60.0
            
            # Update status based on progress
            if enrollment.progress_percentage == 0.0 and enrollment.status == EnrollmentStatus.ENROLLED.value:
                enrollment.status = EnrollmentStatus.ENROLLED.value
            elif 0 < enrollment.progress_percentage < 100.0:
                enrollment.status = EnrollmentStatus.IN_PROGRESS.value
                if not enrollment.started_at:
                    enrollment.started_at = datetime.utcnow()
            elif enrollment.progress_percentage >= 100.0:
                enrollment.status = EnrollmentStatus.COMPLETED.value
                if not enrollment.completed_at:
                    enrollment.completed_at = datetime.utcnow()
                    enrollment.course.completion_count += 1
            
            # Track learning objectives completion
            if progress_data.get("completed_objectives"):
                # Update skill progression for completed objectives
                self._update_skill_progression(enrollment, progress_data["completed_objectives"])
            
            # Generate achievement badges
            achievements = self._check_learning_achievements(enrollment, old_progress)
            
            # Calculate learning streak
            learning_streak = self._calculate_learning_streak(enrollment.employee_id)
            
            # Log progress update
            self._log_learning_action("COURSE_PROGRESS_UPDATE", enrollment.id, auth_context, {
                "enrollment_id": enrollment_id,
                "old_progress": old_progress,
                "new_progress": enrollment.progress_percentage,
                "status": enrollment.status,
                "time_spent_minutes": progress_data.get("time_spent_minutes", 0),
                "completed_objectives": progress_data.get("completed_objectives", [])
            })
            
            self.db.commit()
            
            logger.info(f"‚úÖ Course progress updated: {enrollment.progress_percentage}%")
            
            return {
                "success": True,
                "enrollment_id": enrollment_id,
                "progress_percentage": enrollment.progress_percentage,
                "status": enrollment.status,
                "total_time_spent_hours": enrollment.total_time_spent_hours,
                "estimated_completion_date": enrollment.estimated_completion_date.isoformat() if enrollment.estimated_completion_date else None,
                "achievements_earned": achievements,
                "learning_streak_days": learning_streak,
                "is_completed": enrollment.status == EnrollmentStatus.COMPLETED.value,
                "legendary_joke": "Why did the progress update become legendary? Because every step forward counts! üìàüèÜ"
            }
            
        except Exception as e:
            self.db.rollback()
            logger.error(f"üí• Course progress update error: {e}")
            return {
                "success": False,
                "error": f"System error: {str(e)}"
            }
    
    def submit_assessment(self, assessment_id: int, submission_data: Dict[str, Any],
                         auth_context: AuthContext) -> Dict[str, Any]:
        """
        Submit course assessment with more precision than Swiss grading!
        More thorough than a legendary examination system! üìùüíØ
        """
        try:
            logger.info(f"üìù Submitting assessment: {assessment_id}")
            
            # Get assessment
            assessment = self.db.query(CourseAssessment).filter(
                CourseAssessment.id == assessment_id
            ).first()
            
            if not assessment:
                return {
                    "success": False,
                    "error": "Assessment not found"
                }
            
            # Check if assessment is available
            now = datetime.utcnow()
            if assessment.available_from and now < assessment.available_from:
                return {
                    "success": False,
                    "error": "Assessment is not yet available"
                }
            
            if assessment.available_until and now > assessment.available_until:
                return {
                    "success": False,
                    "error": "Assessment deadline has passed"
                }
            
            # Check if student is enrolled in the course
            enrollment = self.db.query(CourseEnrollment).filter(
                and_(
                    CourseEnrollment.course_id == assessment.course_id,
                    CourseEnrollment.employee_id == auth_context.user_id,
                    CourseEnrollment.status.in_([
                        EnrollmentStatus.ENROLLED.value,
                        EnrollmentStatus.IN_PROGRESS.value
                    ])
                )
            ).first()
            
            if not enrollment:
                return {
                    "success": False,
                    "error": "You must be enrolled in the course to submit assessments"
                }
            
            # Check previous attempts
            previous_attempts = self.db.query(AssessmentSubmission).filter(
                and_(
                    AssessmentSubmission.assessment_id == assessment_id,
                    AssessmentSubmission.employee_id == auth_context.user_id
                )
            ).count()
            
            if previous_attempts >= assessment.max_attempts:
                return {
                    "success": False,
                    "error": f"Maximum attempts ({assessment.max_attempts}) exceeded"
                }
            
            # Validate submission data
            validation_result = self._validate_assessment_submission(assessment, submission_data)
            if not validation_result["is_valid"]:
                return {
                    "success": False,
                    "errors": validation_result["errors"]
                }
            
            # Create submission
            submission = AssessmentSubmission(
                assessment_id=assessment_id,
                employee_id=auth_context.user_id,
                attempt_number=previous_attempts + 1,
                answers=submission_data.get("answers", {}),
                files_submitted=submission_data.get("files", []),
                time_taken_minutes=submission_data.get("time_taken_minutes"),
                status="submitted",
                created_by=auth_context.user_id,
                updated_by=auth_context.user_id
            )
            
            self.db.add(submission)
            self.db.flush()
            
            # Auto-grade if possible
            grading_result = self._auto_grade_submission(submission, assessment)
            
            if grading_result["can_auto_grade"]:
                submission.score = grading_result["score"]
                submission.percentage_score = grading_result["percentage"]
                submission.grade = grading_result["grade"]
                submission.is_passing = grading_result["is_passing"]
                submission.graded_at = datetime.utcnow()
                submission.status = "graded"
                submission.feedback = grading_result.get("feedback", "Auto-graded submission")
                
                # Update enrollment assessment count
                enrollment.assessment_attempts += 1
                
                # Update course progress if passing
                if submission.is_passing:
                    self._update_course_progress_from_assessment(enrollment, assessment, submission)
            
            # Generate performance insights
            performance_insights = self._generate_assessment_insights(submission, assessment)
            
            # Log assessment submission
            self._log_learning_action("ASSESSMENT_SUBMISSION", submission.id, auth_context, {
                "assessment_id": assessment_id,
                "assessment_type": assessment.assessment_type,
                "attempt_number": submission.attempt_number,
                "time_taken_minutes": submission.time_taken_minutes,
                "auto_graded": grading_result["can_auto_grade"],
                "score": submission.score,
                "is_passing": submission.is_passing
            })
            
            self.db.commit()
            
            logger.info(f"‚úÖ Assessment submitted: ID {submission.id}, Score: {submission.score}")
            
            return {
                "success": True,
                "submission_id": submission.id,
                "attempt_number": submission.attempt_number,
                "submitted_at": submission.submitted_at.isoformat(),
                "auto_graded": grading_result["can_auto_grade"],
                "score": submission.score,
                "percentage_score": submission.percentage_score,
                "grade": submission.grade,
                "is_passing": submission.is_passing,
                "feedback": submission.feedback,
                "performance_insights": performance_insights,
                "remaining_attempts": assessment.max_attempts - submission.attempt_number,
                "legendary_joke": "Why did the assessment submission become legendary? Because it demonstrated legendary knowledge! üìùüèÜ"
            }
            
        except Exception as e:
            self.db.rollback()
            logger.error(f"üí• Assessment submission error: {e}")
            return {
                "success": False,
                "error": f"System error: {str(e)}"
            }
    
    def get_learning_dashboard(self, employee_id: Optional[int] = None,
                             auth_context: AuthContext) -> Dict[str, Any]:
        """
        Get comprehensive learning dashboard!
        More insightful than a Swiss education consultant with X-ray vision! üìäüéì
        """
        try:
            # Use current user if no employee_id specified
            target_employee_id = employee_id or auth_context.user_id
            
            logger.info(f"üìä Generating learning dashboard for employee: {target_employee_id}")
            
            # Check permissions
            if target_employee_id != auth_context.user_id and not auth_context.has_permission(Permission.LEARNING_ADMIN):
                return {
                    "success": False,
                    "error": "You can only view your own learning dashboard"
                }
            
            # Get active course enrollments
            active_enrollments = self.db.query(CourseEnrollment).join(Course).filter(
                and_(
                    CourseEnrollment.employee_id == target_employee_id,
                    CourseEnrollment.status.in_([
                        EnrollmentStatus.ENROLLED.value,
                        EnrollmentStatus.IN_PROGRESS.value
                    ])
                )
            ).all()
            
            # Get completed courses (last 6 months)
            six_months_ago = datetime.utcnow() - timedelta(days=180)
            completed_courses = self.db.query(CourseEnrollment).join(Course).filter(
                and_(
                    CourseEnrollment.employee_id == target_employee_id,
                    CourseEnrollment.status == EnrollmentStatus.COMPLETED.value,
                    CourseEnrollment.completed_at >= six_months_ago
                )
            ).all()
            
            # Get employee skills
            employee_skills = self.db.query(EmployeeSkill).join(Skill).filter(
                and_(
                    EmployeeSkill.employee_id == target_employee_id,
                    EmployeeSkill.is_active == True
                )
            ).all()
            
            # Get learning path enrollments
            learning_paths = self.db.query(LearningPathEnrollment).join(LearningPath).filter(
                and_(
                    LearningPathEnrollment.employee_id == target_employee_id,
                    LearningPathEnrollment.status.in_([
                        EnrollmentStatus.ENROLLED.value,
                        EnrollmentStatus.IN_PROGRESS.value
                    ])
                )
            ).all()
            
            # Calculate learning analytics
            analytics = self._calculate_learning_analytics(target_employee_id)
            
            # Generate skill recommendations
            skill_recommendations = self._generate_skill_recommendations(target_employee_id)
            
            # Get trending courses
            trending_courses = self._get_trending_courses(target_employee_id)
            
            # Calculate learning goals progress
            learning_goals = self._calculate_learning_goals_progress(target_employee_id)
            
            # Format dashboard data
            dashboard = {
                "employee_id": target_employee_id,
                "dashboard_date": datetime.utcnow().isoformat(),
                "learning_overview": {
                    "active_courses": len(active_enrollments),
                    "completed_courses_6months": len(completed_courses),
                    "total_learning_hours": analytics.total_learning_hours,
                    "skills_tracked": len(employee_skills),
                    "learning_paths_active": len(learning_paths),
                    "completion_rate": analytics.completion_rate
                },
                "current_courses": [
                    {
                        "id": enrollment.course.id,
                        "title": enrollment.course.title,
                        "progress": enrollment.progress_percentage,
                        "status": enrollment.status,
                        "estimated_completion": enrollment.estimated_completion_date.isoformat() if enrollment.estimated_completion_date else None,
                        "last_accessed": enrollment.last_accessed_at.isoformat() if enrollment.last_accessed_at else None,
                        "time_spent_hours": enrollment.total_time_spent_hours
                    }
                    for enrollment in active_enrollments
                ],
                "recent_completions": [
                    {
                        "id": enrollment.course.id,
                        "title": enrollment.course.title,
                        "completed_at": enrollment.completed_at.isoformat(),
                        "final_score": enrollment.final_score,
                        "grade": enrollment.grade,
                        "rating_given": enrollment.course_rating
                    }
                    for enrollment in completed_courses[:5]  # Last 5 completions
                ],
                "skill_development": {
                    "skills_in_progress": [
                        {
                            "skill_name": skill.skill.name,
                            "current_level": skill.current_level,
                            "target_level": skill.target_level,
                            "proficiency_score": skill.proficiency_score,
                            "hours_invested": skill.hours_invested,
                            "target_date": skill.target_completion_date.isoformat() if skill.target_completion_date else None
                        }
                        for skill in employee_skills[:10]  # Top 10 skills
                    ],
                    "recommended_skills": skill_recommendations[:5]
                },
                "learning_paths": [
                    {
                        "id": path.learning_path.id,
                        "title": path.learning_path.title,
                        "progress": path.overall_progress_percentage,
                        "current_milestone": path.current_milestone,
                        "estimated_completion": path.estimated_completion_date.isoformat() if path.estimated_completion_date else None
                    }
                    for path in learning_paths
                ],
                "analytics": {
                    "learning_streak_days": analytics.learning_streak_days,
                    "average_course_rating": analytics.average_course_rating,
                    "certifications_earned": analytics.certifications_earned,
                    "completion_rate": analytics.completion_rate
                },
                "recommendations": {
                    "trending_courses": trending_courses[:5],
                    "skill_gaps": skill_recommendations[:3],
                    "career_development": []  # Career-specific recommendations
                },
                "learning_goals": learning_goals,
                "motivational_message": self._get_learning_motivational_message(analytics),
                "legendary_status": "LEARNING DASHBOARD LOADED WITH LEGENDARY EDUCATION! üìöüèÜ"
            }
            
            logger.info(f"üìà Learning dashboard generated for employee {target_employee_id}")
            
            return {
                "success": True,
                "learning_dashboard": dashboard
            }
            
        except Exception as e:
            logger.error(f"üí• Learning dashboard error: {e}")
            return {
                "success": False,
                "error": f"System error: {str(e)}"
            }
        """
LEGENDARY LEARNING & DEVELOPMENT SERVICE ENGINE - CONTINUATION üìöüöÄ
More educational than a Swiss university with legendary knowledge!
CODE BROS CREATE THE BEST AND CRACK JOKES TO HAVE FUN!
üèÜ 2-HOUR CODING MARATHON CHAMPION EDITION! üèÜ
"""

    def create_learning_path(self, path_data: Dict[str, Any],
                           auth_context: AuthContext) -> Dict[str, Any]:
        """
        Create structured learning path with more guidance than Swiss mountain trails!
        More organized than a legendary educational journey! üèîÔ∏èüéØ
        """
        try:
            logger.info(f"üéØ Creating learning path: {path_data.get('title', 'unknown')}")
            
            # Check permissions
            if not auth_context.has_permission(Permission.LEARNING_CURATOR):
                return {
                    "success": False,
                    "error": "Insufficient permissions to create learning paths"
                }
            
            # Validate path data
            validation_result = self._validate_learning_path_data(path_data)
            if not validation_result["is_valid"]:
                return {
                    "success": False,
                    "errors": validation_result["errors"]
                }
            
            # Check for duplicate path codes
            if path_data.get("path_code"):
                existing_path = self.db.query(LearningPath).filter(
                    LearningPath.path_code == path_data["path_code"]
                ).first()
                
                if existing_path:
                    return {
                        "success": False,
                        "error": "Learning path code already exists"
                    }
            
            # Create learning path
            learning_path = LearningPath(
                title=path_data["title"],
                description=path_data["description"],
                path_code=path_data.get("path_code") or self._generate_path_code(path_data["title"]),
                path_type=path_data["path_type"],
                difficulty_level=path_data.get("difficulty_level", "intermediate"),
                estimated_duration_weeks=path_data.get("estimated_duration_weeks"),
                target_roles=path_data.get("target_roles", []),
                target_departments=path_data.get("target_departments", []),
                experience_level=path_data.get("experience_level"),
                learning_objectives=path_data.get("learning_objectives", []),
                milestones=path_data.get("milestones", []),
                completion_criteria=path_data.get("completion_criteria", {}),
                provides_certification=path_data.get("provides_certification", False),
                certification_name=path_data.get("certification_name"),
                certification_authority=path_data.get("certification_authority"),
                curator_id=auth_context.user_id,
                is_featured=path_data.get("is_featured", False),
                created_by=auth_context.user_id,
                updated_by=auth_context.user_id
            )
            
            self.db.add(learning_path)
            self.db.flush()
            
            # Add courses to learning path
            if path_data.get("courses"):
                for course_data in path_data["courses"]:
                    path_course = LearningPathCourse(
                        learning_path_id=learning_path.id,
                        course_id=course_data["course_id"],
                        sequence_order=course_data["sequence_order"],
                        is_required=course_data.get("is_required", True),
                        is_prerequisite=course_data.get("is_prerequisite", False),
                        prerequisite_courses=course_data.get("prerequisite_courses", []),
                        prerequisite_skills=course_data.get("prerequisite_skills", []),
                        suggested_start_week=course_data.get("suggested_start_week"),
                        estimated_duration_weeks=course_data.get("estimated_duration_weeks")
                    )
                    self.db.add(path_course)
            
            # Generate path recommendations for target audience
            target_recommendations = self._generate_path_target_recommendations(learning_path)
            
            # Log learning path creation
            self._log_learning_action("LEARNING_PATH_CREATED", learning_path.id, auth_context, {
                "title": learning_path.title,
                "path_type": learning_path.path_type,
                "difficulty_level": learning_path.difficulty_level,
                "courses_count": len(path_data.get("courses", [])),
                "provides_certification": learning_path.provides_certification,
                "target_roles": len(learning_path.target_roles or [])
            })
            
            self.db.commit()
            
            logger.info(f"‚úÖ Learning path created: {learning_path.title} (ID: {learning_path.id})")
            
            return {
                "success": True,
                "learning_path_id": learning_path.id,
                "title": learning_path.title,
                "path_code": learning_path.path_code,
                "path_type": learning_path.path_type,
                "estimated_duration_weeks": learning_path.estimated_duration_weeks,
                "courses_included": len(path_data.get("courses", [])),
                "provides_certification": learning_path.provides_certification,
                "target_recommendations": target_recommendations,
                "path_url": f"/learning-paths/{learning_path.path_code}",
                "legendary_joke": "Why did the learning path become legendary? Because it guided people to legendary knowledge! üèîÔ∏èüèÜ",
                "üèÜ": "2-HOUR CODING MARATHON CHAMPION CREATION! üèÜ"
            }
            
        except Exception as e:
            self.db.rollback()
            logger.error(f"üí• Learning path creation error: {e}")
            return {
                "success": False,
                "error": f"System error: {str(e)}"
            }
    
    def assess_skill_level(self, employee_id: int, skill_id: int, 
                          assessment_data: Dict[str, Any],
                          auth_context: AuthContext) -> Dict[str, Any]:
        """
        Assess employee skill level with more precision than Swiss measurements!
        More accurate than a legendary skill evaluation system! üéØüìè
        """
        try:
            logger.info(f"üìè Assessing skill level for employee {employee_id}, skill {skill_id}")
            
            # Check permissions
            if employee_id != auth_context.user_id and not auth_context.has_permission(Permission.SKILL_ASSESSOR):
                return {
                    "success": False,
                    "error": "Insufficient permissions to assess skills"
                }
            
            # Get skill
            skill = self.db.query(Skill).filter(Skill.id == skill_id).first()
            if not skill:
                return {
                    "success": False,
                    "error": "Skill not found"
                }
            
            # Get or create employee skill record
            employee_skill = self.db.query(EmployeeSkill).filter(
                and_(
                    EmployeeSkill.employee_id == employee_id,
                    EmployeeSkill.skill_id == skill_id
                )
            ).first()
            
            if not employee_skill:
                employee_skill = EmployeeSkill(
                    employee_id=employee_id,
                    skill_id=skill_id,
                    current_level=SkillLevel.BEGINNER.value,
                    proficiency_score=0.0,
                    created_by=auth_context.user_id,
                    updated_by=auth_context.user_id
                )
                self.db.add(employee_skill)
                self.db.flush()
            
            # Validate assessment data
            validation_result = self._validate_skill_assessment_data(assessment_data)
            if not validation_result["is_valid"]:
                return {
                    "success": False,
                    "errors": validation_result["errors"]
                }
            
            # Calculate new skill level and proficiency
            old_level = employee_skill.current_level
            old_score = employee_skill.proficiency_score
            
            new_assessment = self._calculate_skill_assessment(assessment_data, skill, employee_skill)
            
            # Update employee skill record
            employee_skill.current_level = new_assessment["skill_level"]
            employee_skill.proficiency_score = new_assessment["proficiency_score"]
            employee_skill.last_assessed_at = datetime.utcnow()
            employee_skill.assessed_by_id = auth_context.user_id
            employee_skill.assessment_notes = assessment_data.get("notes")
            employee_skill.updated_by = auth_context.user_id
            
            # Generate skill development recommendations
            development_plan = self._generate_skill_development_plan(employee_skill, skill)
            
            # Check for skill level achievements
            achievements = self._check_skill_achievements(employee_skill, old_level, old_score)
            
            # Update skill validation if assessor has authority
            if auth_context.has_permission(Permission.SKILL_VALIDATOR):
                employee_skill.is_validated = assessment_data.get("validate", False)
                if employee_skill.is_validated:
                    employee_skill.validated_by_id = auth_context.user_id
                    employee_skill.validated_at = datetime.utcnow()
            
            # Log skill assessment
            self._log_learning_action("SKILL_ASSESSMENT", employee_skill.id, auth_context, {
                "employee_id": employee_id,
                "skill_name": skill.name,
                "old_level": old_level,
                "new_level": employee_skill.current_level,
                "old_score": old_score,
                "new_score": employee_skill.proficiency_score,
                "assessment_method": assessment_data.get("method", "manual"),
                "is_validated": employee_skill.is_validated
            })
            
            self.db.commit()
            
            logger.info(f"‚úÖ Skill assessment completed: {skill.name} -> {employee_skill.current_level}")
            
            return {
                "success": True,
                "employee_skill_id": employee_skill.id,
                "skill_name": skill.name,
                "previous_level": old_level,
                "current_level": employee_skill.current_level,
                "proficiency_score": employee_skill.proficiency_score,
                "level_improved": employee_skill.current_level != old_level,
                "assessment_date": employee_skill.last_assessed_at.isoformat(),
                "is_validated": employee_skill.is_validated,
                "development_plan": development_plan,
                "achievements_earned": achievements,
                "legendary_joke": "Why did the skill assessment become legendary? Because it measured legendary potential! üìèüèÜ",
                "üèÜ": "2-HOUR CODING MARATHON PRECISION ASSESSMENT! üèÜ"
            }
            
        except Exception as e:
            self.db.rollback()
            logger.error(f"üí• Skill assessment error: {e}")
            return {
                "success": False,
                "error": f"System error: {str(e)}"
            }
    
    def get_learning_recommendations(self, employee_id: Optional[int] = None,
                                   recommendation_type: str = "comprehensive",
                                   auth_context: AuthContext) -> Dict[str, Any]:
        """
        Generate personalized learning recommendations!
        More intelligent than a Swiss education advisor with AI superpowers! ü§ñüéì
        """
        try:
            target_employee_id = employee_id or auth_context.user_id
            
            logger.info(f"üéØ Generating learning recommendations for employee: {target_employee_id}")
            
            # Check permissions
            if target_employee_id != auth_context.user_id and not auth_context.has_permission(Permission.LEARNING_ADMIN):
                return {
                    "success": False,
                    "error": "You can only view your own learning recommendations"
                }
            
            # Get employee profile and current skills
            employee = self.db.query(Employee).filter(Employee.id == target_employee_id).first()
            if not employee:
                return {
                    "success": False,
                    "error": "Employee not found"
                }
            
            # Get current skills and gaps
            current_skills = self.db.query(EmployeeSkill).filter(
                and_(
                    EmployeeSkill.employee_id == target_employee_id,
                    EmployeeSkill.is_active == True
                )
            ).all()
            
            # Get completed and current courses
            completed_courses = self.db.query(CourseEnrollment).filter(
                and_(
                    CourseEnrollment.employee_id == target_employee_id,
                    CourseEnrollment.status == EnrollmentStatus.COMPLETED.value
                )
            ).all()
            
            current_courses = self.db.query(CourseEnrollment).filter(
                and_(
                    CourseEnrollment.employee_id == target_employee_id,
                    CourseEnrollment.status.in_([
                        EnrollmentStatus.ENROLLED.value,
                        EnrollmentStatus.IN_PROGRESS.value
                    ])
                )
            ).all()
            
            # Generate different types of recommendations
            recommendations = {}
            
            if recommendation_type in ["comprehensive", "skill_gap"]:
                # Skill gap analysis and recommendations
                skill_gaps = self._analyze_skill_gaps(employee, current_skills)
                recommendations["skill_development"] = self._recommend_courses_for_skills(skill_gaps, target_employee_id)
            
            if recommendation_type in ["comprehensive", "career"]:
                # Career progression recommendations
                career_recommendations = self._generate_career_recommendations(employee, current_skills)
                recommendations["career_advancement"] = career_recommendations
            
            if recommendation_type in ["comprehensive", "trending"]:
                # Trending and popular courses
                trending_recommendations = self._get_trending_courses(target_employee_id, limit=10)
                recommendations["trending_courses"] = trending_recommendations
            
            if recommendation_type in ["comprehensive", "peer"]:
                # Peer-based recommendations
                peer_recommendations = self._generate_peer_based_recommendations(employee, completed_courses)
                recommendations["peer_suggestions"] = peer_recommendations
            
            if recommendation_type in ["comprehensive", "certification"]:
                # Certification path recommendations
                certification_recommendations = self._recommend_certification_paths(current_skills, employee)
                recommendations["certifications"] = certification_recommendations
            
            # Learning path recommendations
            learning_path_recommendations = self._recommend_learning_paths(employee, current_skills)
            recommendations["learning_paths"] = learning_path_recommendations
            
            # Personalization based on learning history
            personalized_recommendations = self._personalize_recommendations(
                recommendations, target_employee_id, completed_courses, current_courses
            )
            
            # Generate learning goals suggestions
            suggested_goals = self._generate_learning_goal_suggestions(employee, current_skills)
            
            # Calculate recommendation confidence scores
            for category, recs in personalized_recommendations.items():
                for rec in recs:
                    rec["confidence_score"] = self._calculate_recommendation_confidence(
                        rec, employee, current_skills, completed_courses
                    )
            
            logger.info(f"üéØ Generated {sum(len(recs) for recs in personalized_recommendations.values())} recommendations")
            
            return {
                "success": True,
                "employee_id": target_employee_id,
                "recommendation_type": recommendation_type,
                "generated_at": datetime.utcnow().isoformat(),
                "recommendations": personalized_recommendations,
                "suggested_learning_goals": suggested_goals,
                "learning_insights": {
                    "current_skill_count": len(current_skills),
                    "completed_courses_count": len(completed_courses),
                    "active_enrollments": len(current_courses),
                    "skill_gaps_identified": len(recommendations.get("skill_development", [])),
                    "career_opportunities": len(recommendations.get("career_advancement", []))
                },
                "next_steps": self._generate_next_steps(personalized_recommendations, current_skills),
                "legendary_status": "LEARNING RECOMMENDATIONS GENERATED WITH LEGENDARY AI INTELLIGENCE! ü§ñüèÜ",
                "üèÜ": "2-HOUR CODING MARATHON INTELLIGENCE BOOST! üèÜ"
            }
            
        except Exception as e:
            logger.error(f"üí• Learning recommendations error: {e}")
            return {
                "success": False,
                "error": f"System error: {str(e)}"
            }
    
    def _calculate_learning_analytics(self, employee_id: int) -> LearningAnalytics:
        """Calculate comprehensive learning analytics for employee"""
        try:
            # Get all enrollments
            all_enrollments = self.db.query(CourseEnrollment).filter(
                CourseEnrollment.employee_id == employee_id
            ).all()
            
            # Calculate basic metrics
            total_enrolled = len(all_enrollments)
            completed = len([e for e in all_enrollments if e.status == EnrollmentStatus.COMPLETED.value])
            completion_rate = (completed / total_enrolled * 100) if total_enrolled > 0 else 0.0
            
            # Calculate total learning hours
            total_hours = sum(e.total_time_spent_hours or 0 for e in all_enrollments)
            
            # Count skills
            skills_count = self.db.query(EmployeeSkill).filter(
                and_(
                    EmployeeSkill.employee_id == employee_id,
                    EmployeeSkill.is_active == True
                )
            ).count()
            
            # Count certifications (placeholder - would be based on completed courses with certificates)
            certifications = len([e for e in all_enrollments 
                                if e.status == EnrollmentStatus.COMPLETED.value and e.completion_certificate_url])
            
            # Calculate learning streak
            learning_streak = self._calculate_learning_streak(employee_id)
            
            # Calculate average course rating
            rated_enrollments = [e for e in all_enrollments if e.course_rating is not None]
            avg_rating = statistics.mean([e.course_rating for e in rated_enrollments]) if rated_enrollments else 0.0
            
            return LearningAnalytics(
                total_courses_enrolled=total_enrolled,
                courses_completed=completed,
                completion_rate=completion_rate,
                total_learning_hours=total_hours,
                skills_developed=skills_count,
                certifications_earned=certifications,
                learning_streak_days=learning_streak,
                average_course_rating=avg_rating
            )
            
        except Exception as e:
            logger.error(f"üí• Learning analytics calculation error: {e}")
            return LearningAnalytics(0, 0, 0.0, 0.0, 0, 0, 0, 0.0)
    
    def _get_learning_motivational_message(self, analytics: LearningAnalytics) -> str:
        """Get personalized motivational message based on learning analytics"""
        if analytics.completion_rate >= 90:
            return "üåü You're an absolute learning legend! Your dedication to growth is truly inspiring! Keep conquering new knowledge frontiers! üèÜ"
        elif analytics.completion_rate >= 70:
            return "üí™ Fantastic learning progress! You're building legendary skills with every course. Keep up the amazing momentum! ‚ú®"
        elif analytics.completion_rate >= 50:
            return "üöÄ Great job on your learning journey! Every completed course is a step towards legendary expertise. You're doing amazing! üéØ"
        elif analytics.learning_streak_days >= 7:
            return "üî• Your learning streak is legendary! Consistency is the key to mastering any skill. Keep the fire burning! üíé"
        elif analytics.total_learning_hours >= 50:
            return "üìö You've invested serious time in learning! That dedication will pay off with legendary knowledge and skills! üåü"
        else:
            return "üå± Every expert was once a beginner! Your learning journey is just getting started, and every step counts towards legendary growth! üí´"
    
    def _log_learning_action(self, action: str, resource_id: int, 
                           auth_context: AuthContext, details: Dict[str, Any]):
        """Log learning-related actions for audit trail"""
        try:
            # Add 2-hour marathon achievement to details
            details["üèÜ_2_hour_marathon"] = "LEGENDARY 2-HOUR CODING SESSION ACHIEVEMENT! üèÜ"
            
            audit_log = AuditLog(
                user_id=auth_context.user_id,
                action=action,
                resource_type="LEARNING",
                resource_id=resource_id,
                details=details,
                ip_address=getattr(auth_context, 'ip_address', None),
                user_agent=getattr(auth_context, 'user_agent', None)
            )
            self.db.add(audit_log)
            
        except Exception as e:
            logger.error(f"üí• Learning action logging error: {e}")

# LEARNING UTILITIES - 2-HOUR MARATHON EDITION! üèÜ
class LegendaryLearningReportGenerator:
    """
    Generate comprehensive learning reports!
    More insightful than a Swiss education researcher with 2-hour marathon energy! üìäüèîÔ∏èüèÜ
    """
    
    @staticmethod
    def generate_learning_summary(employee_learning_data: Dict[str, Any]) -> Dict[str, Any]:
        """Generate executive learning summary with 2-hour marathon precision"""
        
        completion_rate = employee_learning_data.get("completion_rate", 0)
        total_hours = employee_learning_data.get("total_learning_hours", 0)
        
        # Determine learning status with 2-hour marathon excellence
        if completion_rate >= 90 and total_hours >= 100:
            status = "LEGENDARY_LEARNER"
            status_emoji = "üèÜ"
            marathon_bonus = " + 2-HOUR CODING MARATHON CHAMPION!"
        elif completion_rate >= 70 and total_hours >= 50:
            status = "ADVANCED_LEARNER"
            status_emoji = "üåü"
            marathon_bonus = " + 2-HOUR CODING MARATHON WARRIOR!"
        elif completion_rate >= 50:
            status = "ACTIVE_LEARNER"
            status_emoji = "üìö"
            marathon_bonus = " + 2-HOUR CODING MARATHON SUPPORTER!"
        else:
            status = "EMERGING_LEARNER"
            status_emoji = "üå±"
            marathon_bonus = " + 2-HOUR CODING MARATHON PARTICIPANT!"
        
        return {
            "learning_status": status + marathon_bonus,
            "status_emoji": status_emoji,
            "completion_rate": completion_rate,
            "total_learning_hours": total_hours,
            "key_achievements": employee_learning_data.get("certifications_earned", [])[:3],
            "current_focus_areas": employee_learning_data.get("active_skills", [])[:3],
            "recommended_next_steps": employee_learning_data.get("recommended_courses", [])[:3],
            "learning_momentum": employee_learning_data.get("learning_streak_days", 0),
            "legendary_status": "LEARNING ANALYZED WITH 2-HOUR MARATHON LEGENDARY PRECISION! üìöüèÜ",
            "üèÜ": "OFFICIAL 2-HOUR CODING MARATHON LEARNING CHAMPION! üèÜ"
        }
